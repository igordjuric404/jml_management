module.exports=[93695,(e,t,a)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},70406,(e,t,a)=>{t.exports=e.x("next/dist/compiled/@opentelemetry/api",()=>require("next/dist/compiled/@opentelemetry/api"))},18622,(e,t,a)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},56704,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},32319,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},24725,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},20969,e=>{"use strict";let t={overview:{id:"overview",title:"OGM Overview",keywords:["overview","what is","ogm","oauth gap monitor","purpose","about","jml"],content:"OGM (OAuth Gap Monitor) is a post-offboarding access and OAuth gap monitor for Google Workspace. It detects lingering OAuth tokens, ASPs, post-offboarding logins, admin MFA gaps, and DWD risks. Main URL: /dashboard. Key pages: Dashboard (/dashboard), Cases (/cases), Employees (/employees), OAuth Apps (/apps), Findings (/findings), Artifacts (/artifacts), Scan History (/scan-history), Audit Log (/audit-log), Settings (/settings), Docs (/docs)."},remediation:{id:"remediation",title:"Remediation Actions",keywords:["remediate","revoke","delete","sign out","fix","resolve","bundle","action"],content:"Remediation actions: 1) Revoke All OAuth Grants (tokens.delete), 2) Delete All ASPs (asps.delete), 3) Sign Out User Everywhere (users.signOut), 4) Full Remediation Bundle (all of the above + close findings). Available from: case detail page (/cases/{id}), employee page (/employees), artifact list (/artifacts), app dashboard (/apps). After any remediation, case status updates automatically."},findings:{id:"findings",title:"Finding Types",keywords:["finding","issue","vulnerability","gap","security","type","severity"],content:"Finding types: LingeringOAuthGrant (active tokens), LingeringASP (active passwords), PostOffboardLogin (login after leaving), PostOffboardSuspiciousLogin (suspicious login), OffboardingNotEnforced (account not suspended), AdminMFAWeak (admin without 2SV), DWDHighRisk (dangerous domain-wide delegation). Severities: Low, Medium, High, Critical. URL: /findings."},scanning:{id:"scanning",title:"Scanning",keywords:["scan","rescan","discover","detect","hidden","background","system scan"],content:"System Scan: triggered from the Dashboard (/dashboard) via the 'Scan System' button. Discovers hidden leftover access across ALL offboarded employees — tokens, ASPs, logins. Auto-creates cases for new discoveries. Background scan runs on the configured interval (if enabled in Settings). Scan history at /scan-history."},automation:{id:"automation",title:"Automation & Settings",keywords:["automatic","auto","setting","config","toggle","schedule","background","interval"],content:"Settings at /settings: Auto-Scan on Offboarding (off by default), Auto-Remediate on Offboarding (off), Background Scanning (on), Auto-Create Case on Employee Leave (on). Scheduled remediations check every 5 minutes. Notifications for 7-day and 1-day reminders."},cases:{id:"offboarding-case",title:"Offboarding Cases",keywords:["case","offboarding","status","draft","gaps found","remediated","all clear"],content:"Offboarding Cases track user access reviews. Status flow: Draft → (scan) → All Clear or Gaps Found → (remediate) → Remediated → Closed. Can also be Scheduled. Fields: primary_email, employee, event_type, effective_date, status, scheduled_remediation_date. URL: /cases. Detail: /cases/{id}."},artifacts:{id:"artifacts",title:"Access Artifacts",keywords:["artifact","token","asp","login","access","oauth","stored"],content:"Access Artifacts: OAuthToken (third-party OAuth grant), ASP (app-specific password), LoginEvent (login record), AdminMFA (MFA status), DWDChange (domain delegation event). Status: Hidden → (system scan) → Active → Revoked/Deleted/Acknowledged. You can access and manage them at /artifacts."},employees:{id:"employees",title:"Employee Management",keywords:["employee","user","staff","people","hr","who"],content:"Employee Access Overview at /employees. Lists all employees with case/artifact/finding counts. Per-employee detail: info, KPIs, apps used, findings with remediate buttons, cases with resolve buttons. Bulk revoke: select employees and revoke all tokens or ASPs."},apps:{id:"apps",title:"OAuth Applications",keywords:["app","application","oauth","slack","notion","client","grant"],content:"OAuth App Dashboard at /apps. Lists all apps with grant counts. Per-app detail: users with grants, scopes, risk levels. Per-user revoke or global revoke."},audit:{id:"audit-log",title:"Audit Log",keywords:["audit","log","history","trail","who","when","action","track"],content:"Unified Audit Log at /audit-log. Records all OGM actions: scans, remediations, case creation. Fields: actor_user, action_type, target_email, result, remediation_type (manual/automatic/scheduler), timestamp."},navigation:{id:"navigation",title:"Navigation Guide",keywords:["where","find","navigate","page","url","go to","how to get","located","stored"],content:"Dashboard: /dashboard. Cases: /cases. Employees: /employees. Apps: /apps. Findings: /findings. Artifacts: /artifacts. Scan History: /scan-history. Audit Log: /audit-log. Settings: /settings. Docs: /docs. All accessible from the sidebar navigation."}},a=["how many","count","number","total","active","open","status","statistics","stat","finding","artifact","case","critical","remediated","pending","hidden"],s=["where","find","navigate","go to","how to get","located","stored","page","url"];function n(e){let t;if(t=e.toLowerCase(),s.some(e=>t.includes(e)))return!1;let n=e.toLowerCase();return a.some(e=>n.includes(e))}function i(e){let a=e.toLowerCase(),s=[];for(let[e,n]of Object.entries(t)){let t=0;for(let e of n.keywords)a.includes(e)&&(t+=2);for(let e of a.match(/\w+/g)??[])n.content.toLowerCase().includes(e)&&(t+=1);t>0&&s.push([t,e,n])}return s.sort((e,t)=>t[0]-e[0]),s.slice(0,3)}async function o(e){try{let[t,a,s,n,i,o,r,l,d]=await Promise.all([e.getTotalCases(),e.getCaseCounts(),e.getTotalFindings(),e.getOpenFindings(),e.getCriticalFindings(),e.getTotalArtifacts(),e.getActiveArtifacts(),e.getHiddenArtifacts(),e.getOffboardedEmployees()]),c=Object.entries(a).map(([e,t])=>`${e}: ${t}`).join(", ");return`LIVE DATABASE: ${t} total cases (${c}). ${s} total findings (${n} open, ${s-n} closed, ${i} critical open). ${o} total artifacts (${r} active, ${l} hidden/undiscovered). ${d} offboarded employees.`}catch{return""}}let r={overview:"/dashboard",remediation:"/cases",findings:"/findings",scanning:"/scan-history",automation:"/settings","offboarding-case":"/cases",artifacts:"/artifacts",employees:"/employees",apps:"/apps","audit-log":"/audit-log",navigation:"/dashboard"};function l(e){return e.map(([,,e])=>({title:e.title,url:r[e.id]||"/dashboard"}))}function d(e,t,a){if(t.length>0){let s=t[0][2].content;return n(e)&&a&&(s=a+"\n\n"+s),{reply:s,sources:l(t)}}return{reply:"I can help with questions about OGM. Try asking about: findings, remediation, scanning, automation, cases, employees, artifacts, navigation, or the audit log.",sources:[{title:"Dashboard",url:"/dashboard"},{title:"Documentation",url:"/docs"}]}}async function c(e,t,a){try{let s=await fetch("https://openrouter.ai/api/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${a}`,"Content-Type":"application/json"},body:JSON.stringify({model:"google/gemini-2.0-flash-001",messages:[{role:"system",content:"You are the OGM Help Assistant. Answer questions about the OAuth Gap Monitor system. Be concise (2-4 sentences max). Include relevant URLs when helpful (use format /page-name like /artifacts, /cases, /findings). If LIVE DATABASE data is provided, use those exact numbers. Only answer based on provided context."},{role:"user",content:`Context:
${t}

Question: ${e}`}],max_tokens:300,temperature:.3}),signal:AbortSignal.timeout(15e3)});if(!s.ok)return null;let n=await s.json();return n?.choices?.[0]?.message?.content??null}catch{return null}}async function u(e,a){let s;if(!e||e.trim().length<2)return{reply:"Please ask a question about the OGM system.",sources:[]};let r=i(e),u=[];if(n(e)&&a?.liveDataProvider&&(s=await o(a.liveDataProvider))&&u.push(s),r.length>0)for(let[,,e]of r)u.push(`[${e.title}]: ${e.content}`);else u.push(t.overview.content),u.push(t.navigation.content);let p=u.join("\n\n"),g=l(r);if(a?.apiKey){let t=await c(e,p,a.apiKey);if(t)return{reply:t,sources:g}}return d(e,r,s)}e.s(["chat",()=>u,"chatWithLLM",()=>c,"getLiveDataString",()=>o,"localAnswer",()=>d,"needsLiveData",()=>n,"searchKnowledge",()=>i])},99280,e=>{"use strict";var t=e.i(47909),a=e.i(74017),s=e.i(96250),n=e.i(59756),i=e.i(61916),o=e.i(74677),r=e.i(69741),l=e.i(16795),d=e.i(87718),c=e.i(95169),u=e.i(47587),p=e.i(66012),g=e.i(70101),f=e.i(26937),h=e.i(10372),m=e.i(93695);e.i(52474);var v=e.i(220),y=e.i(89171),w=e.i(24223),A=e.i(20969);async function b(e){try{let t=(await e.json()).message,a=process.env.OPENROUTER_API_KEY;if(a){let e=await (0,A.chat)(t,{apiKey:a});return y.NextResponse.json({status:"success",data:e})}let s=(0,w.getProvider)(),n=await s.chat(t);return y.NextResponse.json({status:"success",data:n})}catch(t){let e=t instanceof Error?t.message:"Failed";return y.NextResponse.json({status:"error",error:e},{status:500})}}e.s(["POST",()=>b],1351);var R=e.i(1351);let x=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/chat/route",pathname:"/api/chat",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/chat/route.ts",nextConfigOutput:"standalone",userland:R}),{workAsyncStorage:k,workUnitAsyncStorage:O,serverHooks:E}=x;function C(){return(0,s.patchFetch)({workAsyncStorage:k,workUnitAsyncStorage:O})}async function S(e,t,s){x.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let y="/api/chat/route";y=y.replace(/\/index$/,"")||"/";let w=await x.prepare(e,t,{srcPage:y,multiZoneDraftMode:!1});if(!w)return t.statusCode=400,t.end("Bad Request"),null==s.waitUntil||s.waitUntil.call(s,Promise.resolve()),null;let{buildId:A,params:b,nextConfig:R,parsedUrl:k,isDraftMode:O,prerenderManifest:E,routerServerContext:C,isOnDemandRevalidate:S,revalidateOnlyGenerated:P,resolvedPathname:D,clientReferenceManifest:T,serverActionsManifest:L}=w,_=(0,r.normalizeAppPath)(y),N=!!(E.dynamicRoutes[_]||E.routes[D]),j=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,k,!1):t.end("This page could not be found"),null);if(N&&!O){let e=!!E.routes[D],t=E.dynamicRoutes[_];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await j();throw new m.NoFallbackError}}let M=null;!N||x.isDev||O||(M="/index"===(M=D)?"/":M);let $=!0===x.isDev||!N,F=N&&!$;L&&T&&(0,o.setManifestsSingleton)({page:y,clientReferenceManifest:T,serverActionsManifest:L});let H=e.method||"GET",q=(0,i.getTracer)(),I=q.getActiveScopeSpan(),U={params:b,prerenderManifest:E,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:$,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:s.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,s,n)=>x.onRequestError(e,t,s,n,C)},sharedContext:{buildId:A}},G=new l.NodeNextRequest(e),K=new l.NodeNextResponse(t),B=d.NextRequestAdapter.fromNodeNextRequest(G,(0,d.signalFromNodeResponse)(t));try{let o=async e=>x.handle(B,U).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=q.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let s=a.get("next.route");if(s){let t=`${H} ${s}`;e.setAttributes({"next.route":s,"http.route":s,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${y}`)}),r=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var i,l;let d=async({previousCacheEntry:a})=>{try{if(!r&&S&&P&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await o(n);e.fetchMetrics=U.renderOpts.fetchMetrics;let l=U.renderOpts.pendingWaitUntil;l&&s.waitUntil&&(s.waitUntil(l),l=void 0);let d=U.renderOpts.collectedTags;if(!N)return await (0,p.sendResponse)(G,K,i,U.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,g.toNodeOutgoingHttpHeaders)(i.headers);d&&(t[h.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==U.renderOpts.collectedRevalidate&&!(U.renderOpts.collectedRevalidate>=h.INFINITE_CACHE)&&U.renderOpts.collectedRevalidate,s=void 0===U.renderOpts.collectedExpire||U.renderOpts.collectedExpire>=h.INFINITE_CACHE?void 0:U.renderOpts.collectedExpire;return{value:{kind:v.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:s}}}}catch(t){throw(null==a?void 0:a.isStale)&&await x.onRequestError(e,t,{routerKind:"App Router",routePath:y,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:S})},!1,C),t}},c=await x.handleResponse({req:e,nextConfig:R,cacheKey:M,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:E,isRoutePPREnabled:!1,isOnDemandRevalidate:S,revalidateOnlyGenerated:P,responseGenerator:d,waitUntil:s.waitUntil,isMinimalMode:r});if(!N)return null;if((null==c||null==(i=c.value)?void 0:i.kind)!==v.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(l=c.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",S?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),O&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,g.fromNodeOutgoingHttpHeaders)(c.value.headers);return r&&N||m.delete(h.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,f.getCacheControlHeader)(c.cacheControl)),await (0,p.sendResponse)(G,K,new Response(c.value.body,{headers:m,status:c.value.status||200})),null};I?await l(I):await q.withPropagatedContext(e.headers,()=>q.trace(c.BaseServerSpan.handleRequest,{spanName:`${H} ${y}`,kind:i.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},l))}catch(t){if(t instanceof m.NoFallbackError||await x.onRequestError(e,t,{routerKind:"App Router",routePath:_,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:S})},!1,C),N)throw t;return await (0,p.sendResponse)(G,K,new Response(null,{status:500})),null}}e.s(["handler",()=>S,"patchFetch",()=>C,"routeModule",()=>x,"serverHooks",()=>E,"workAsyncStorage",()=>k,"workUnitAsyncStorage",()=>O],99280)},54006,e=>{e.v(e=>Promise.resolve().then(()=>e(20969)))}];

//# sourceMappingURL=%5Broot-of-the-server%5D__2e0c12dc._.js.map