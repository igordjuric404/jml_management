module.exports=[93695,(e,t,a)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},70406,(e,t,a)=>{t.exports=e.x("next/dist/compiled/@opentelemetry/api",()=>require("next/dist/compiled/@opentelemetry/api"))},18622,(e,t,a)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},56704,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},32319,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},24725,(e,t,a)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},20969,e=>{"use strict";let t={overview:{id:"overview",title:"OGM Overview",keywords:["overview","what is ogm","oauth gap monitor","purpose","jml management"],content:"OGM (OAuth Gap Monitor) is a post-offboarding access and OAuth gap monitor for Google Workspace. It detects lingering OAuth tokens, ASPs, post-offboarding logins, admin MFA gaps, and DWD risks. Main URL: /dashboard. Key pages: Dashboard (/dashboard), Cases (/cases), Employees (/employees), OAuth Apps (/apps), Findings (/findings), Artifacts (/artifacts), Scan History (/scan-history), Audit Log (/audit-log), Settings (/settings), Docs (/docs).",answer:"OGM (OAuth Gap Monitor) is a post-offboarding security tool for Google Workspace. It detects lingering OAuth tokens, app-specific passwords, suspicious logins, and other access gaps after employees leave. You can get started from the **Dashboard**."},remediation:{id:"remediation",title:"Remediation Actions",keywords:["remediate","revoke","delete","sign out","fix","resolve","bundle"],content:"Remediation actions: 1) Revoke All OAuth Grants (tokens.delete), 2) Delete All ASPs (asps.delete), 3) Sign Out User Everywhere (users.signOut), 4) Full Remediation Bundle (all of the above + close findings). Available from: case detail page (/cases/{id}), employee page (/employees), artifact list (/artifacts), app dashboard (/apps). After any remediation, case status updates automatically.",answer:"Remediation lets you revoke lingering access for offboarded employees. Actions include revoking OAuth grants, deleting ASPs, signing out sessions, or running a Full Bundle that does all three and closes findings. You can trigger remediation from any case detail page under **Cases**."},findings:{id:"findings",title:"Finding Types",keywords:["finding","issue","vulnerability","gap","severity"],content:"Finding types: LingeringOAuthGrant (active tokens), LingeringASP (active passwords), PostOffboardLogin (login after leaving), PostOffboardSuspiciousLogin (suspicious login), OffboardingNotEnforced (account not suspended), AdminMFAWeak (admin without 2SV), DWDHighRisk (dangerous domain-wide delegation). Severities: Low, Medium, High, Critical. URL: /findings.",answer:"Findings are security issues discovered during scans. Types include lingering OAuth grants, lingering ASPs, post-offboard logins, weak admin MFA, and risky domain-wide delegation. Each finding has a severity (Low, Medium, High, or Critical). You can review and remediate them on the **Findings** page."},scanning:{id:"scanning",title:"Scanning",keywords:["scan","rescan","discover","detect","hidden","system scan"],content:"System Scan: triggered from the Dashboard (/dashboard) via the 'Scan System' button. Discovers hidden leftover access across ALL offboarded employees — tokens, ASPs, logins. Auto-creates cases for new discoveries. Background scan runs on the configured interval (if enabled in Settings). Scan history at /scan-history.",answer:"You can run a System Scan from the **Dashboard** to discover hidden leftover access across all offboarded employees. It automatically creates cases for any new discoveries. Background scanning can also be enabled in **Settings**. View past scans under **Scan History**."},automation:{id:"automation",title:"Automation & Settings",keywords:["automatic","auto","setting","config","toggle","schedule","background","interval"],content:"Settings at /settings: Auto-Scan on Offboarding (off by default), Auto-Remediate on Offboarding (off), Background Scanning (on), Auto-Create Case on Employee Leave (on). Scheduled remediations check every 5 minutes. Notifications for 7-day and 1-day reminders.",answer:"You can configure automation on the **Settings** page. Options include auto-scan on offboarding, auto-remediation, background scanning, and automatic case creation when employees leave. Notification reminders are sent at 7-day and 1-day intervals."},cases:{id:"offboarding-case",title:"Offboarding Cases",keywords:["case","offboarding","draft","gaps found","remediated","all clear"],content:"Offboarding Cases track user access reviews. Status flow: Draft → (scan) → All Clear or Gaps Found → (remediate) → Remediated → Closed. Can also be Scheduled. Fields: primary_email, employee, event_type, effective_date, status, scheduled_remediation_date. URL: /cases. Detail: /cases/{id}.",answer:"Offboarding Cases track the access review process for departing employees. They follow a status flow: Draft → All Clear or Gaps Found → Remediated → Closed. You can view and manage all cases on the **Cases** page."},artifacts:{id:"artifacts",title:"Access Artifacts",keywords:["artifact","token","asp","login event","access artifact","oauth token"],content:"Access Artifacts: OAuthToken (third-party OAuth grant), ASP (app-specific password), LoginEvent (login record), AdminMFA (MFA status), DWDChange (domain delegation event). Status: Hidden → (system scan) → Active → Revoked/Deleted/Acknowledged. You can access and manage them at /artifacts.",answer:"The artifacts are stored within the OAuth Gap Monitor system. You can access and manage them on the **Artifacts** page. The artifact types are OAuthToken, ASP, LoginEvent, AdminMFA, and DWDChange."},employees:{id:"employees",title:"Employee Management",keywords:["employee","staff","people","personnel"],content:"Employee Access Overview at /employees. Lists all employees with case/artifact/finding counts. Per-employee detail: info, KPIs, apps used, findings with remediate buttons, cases with resolve buttons. Bulk revoke: select employees and revoke all tokens or ASPs.",answer:"You can view all employees and their access status on the **Employees** page. Each employee shows their cases, artifacts, findings, and apps used, with options to remediate directly. Bulk revoke is also available."},apps:{id:"apps",title:"OAuth Applications",keywords:["app","application","oauth app","slack","notion","client","grant"],content:"OAuth App Dashboard at /apps. Lists all apps with grant counts. Per-app detail: users with grants, scopes, risk levels. Per-user revoke or global revoke.",answer:"You can see all your OAuth apps on the **Apps** page. It lists every third-party application with active grants, showing user counts and scopes. You can revoke access per-user or globally."},audit:{id:"audit-log",title:"Audit Log",keywords:["audit","log","trail","action history"],content:"Unified Audit Log at /audit-log. Records all OGM actions: scans, remediations, case creation. Fields: actor_user, action_type, target_email, result, remediation_type (manual/automatic/scheduler), timestamp.",answer:"The Audit Log records every action in the system — scans, remediations, and case changes. You can review the full history on the **Audit Log** page."},navigation:{id:"navigation",title:"Navigation Guide",keywords:["navigate","page","url","sidebar","menu"],content:"Dashboard: /dashboard. Cases: /cases. Employees: /employees. Apps: /apps. Findings: /findings. Artifacts: /artifacts. Scan History: /scan-history. Audit Log: /audit-log. Settings: /settings. Docs: /docs. All accessible from the sidebar navigation.",answer:"All pages are accessible from the sidebar. Key areas: **Dashboard**, **Cases**, **Employees**, **Apps**, **Findings**, **Artifacts**, **Audit Log**, and **Settings**."}},a=["how many","count","number","total","active","open","status","statistics","stat","finding","artifact","case","critical","remediated","pending","hidden"],s=["where","find","navigate","go to","how to get","located","stored","page","url"];function n(e){let t;if(t=e.toLowerCase(),s.some(e=>t.includes(e)))return!1;let n=e.toLowerCase();return a.some(e=>n.includes(e))}let i=new Set(["a","an","the","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","shall","should","may","might","must","can","could","i","me","my","we","our","you","your","he","she","it","they","them","this","that","these","those","am","or","and","but","if","not","no","so","up","out","on","off","in","to","at","of","for","by","with","from","as","into","about","how","what","which","who","whom","when","where","why","all","each","any","both","more","most","some","such","than","too","very","just","also","there","here","then"]),o=new Set(["navigation","overview"]);function r(e){let a=e.toLowerCase(),s=[],n=!1;for(let[e,r]of Object.entries(t)){let t=0,d=!1;for(let e of r.keywords)a.includes(e)&&(t+=10,d=!0);for(let e of(a.match(/\w+/g)??[]).filter(e=>e.length>=4&&!i.has(e)))r.content.toLowerCase().includes(e)&&(t+=1);t>0&&(s.push([t,e,r]),d&&!o.has(e)&&(n=!0))}if(s.sort((e,t)=>t[0]-e[0]),n&&s.length>=2&&o.has(s[0][1])){let e=s.findIndex(([,e])=>!o.has(e));if(e>0){let[t]=s.splice(e,1);s.unshift(t)}}return s.slice(0,3)}async function d(e){try{let[t,a,s,n,i,o,r,d,l]=await Promise.all([e.getTotalCases(),e.getCaseCounts(),e.getTotalFindings(),e.getOpenFindings(),e.getCriticalFindings(),e.getTotalArtifacts(),e.getActiveArtifacts(),e.getHiddenArtifacts(),e.getOffboardedEmployees()]),c=Object.entries(a).map(([e,t])=>`${e}: ${t}`).join(", ");return`LIVE DATABASE: ${t} total cases (${c}). ${s} total findings (${n} open, ${s-n} closed, ${i} critical open). ${o} total artifacts (${r} active, ${d} hidden/undiscovered). ${l} offboarded employees.`}catch{return""}}let l={overview:"/dashboard",remediation:"/cases",findings:"/findings",scanning:"/scan-history",automation:"/settings","offboarding-case":"/cases",artifacts:"/artifacts",employees:"/employees",apps:"/apps","audit-log":"/audit-log",navigation:"/dashboard"};function c(e){return e.map(([,,e])=>({title:e.title,url:l[e.id]||"/dashboard"}))}function u(e,t,a){if(t.length>0){let s=t[0][2].answer;return n(e)&&a&&(s=a+"\n\n"+s),{reply:s,sources:c(t)}}return{reply:"I can help with questions about OGM. Try asking about: findings, remediation, scanning, automation, cases, employees, artifacts, navigation, or the audit log.",sources:[{title:"Dashboard",url:"/dashboard"},{title:"Documentation",url:"/docs"}]}}async function p(e,t,a){try{let s=await fetch("https://openrouter.ai/api/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${a}`,"Content-Type":"application/json"},body:JSON.stringify({model:"google/gemini-2.0-flash-001",messages:[{role:"system",content:"You are the OGM Help Assistant. Answer questions about the OAuth Gap Monitor system. Be concise (2-4 sentences max). Include relevant URLs when helpful (use format /page-name like /artifacts, /cases, /findings). If LIVE DATABASE data is provided, use those exact numbers. Only answer based on provided context."},{role:"user",content:`Context:
${t}

Question: ${e}`}],max_tokens:300,temperature:.3}),signal:AbortSignal.timeout(15e3)});if(!s.ok)return null;let n=await s.json();return n?.choices?.[0]?.message?.content??null}catch{return null}}async function g(e,a){let s;if(!e||e.trim().length<2)return{reply:"Please ask a question about the OGM system.",sources:[]};let i=r(e),o=[];if(n(e)&&a?.liveDataProvider&&(s=await d(a.liveDataProvider))&&o.push(s),i.length>0)for(let[,,e]of i)o.push(`[${e.title}]: ${e.content}`);else o.push(t.overview.content),o.push(t.navigation.content);let l=o.join("\n\n"),g=c(i);if(a?.apiKey){let t=await p(e,l,a.apiKey);if(t)return{reply:t,sources:g}}return u(e,i,s)}e.s(["chat",()=>g,"chatWithLLM",()=>p,"getLiveDataString",()=>d,"localAnswer",()=>u,"needsLiveData",()=>n,"searchKnowledge",()=>r])},99280,e=>{"use strict";var t=e.i(47909),a=e.i(74017),s=e.i(96250),n=e.i(59756),i=e.i(61916),o=e.i(74677),r=e.i(69741),d=e.i(16795),l=e.i(87718),c=e.i(95169),u=e.i(47587),p=e.i(66012),g=e.i(70101),h=e.i(26937),f=e.i(10372),m=e.i(93695);e.i(52474);var y=e.i(220),v=e.i(89171),w=e.i(20969);async function A(e){try{let t=(await e.json()).message,a=process.env.OPENROUTER_API_KEY||void 0,s=await (0,w.chat)(t,{apiKey:a});return v.NextResponse.json({status:"success",data:s})}catch(t){let e=t instanceof Error?t.message:"Failed";return v.NextResponse.json({status:"error",error:e},{status:500})}}e.s(["POST",()=>A],1351);var b=e.i(1351);let k=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/chat/route",pathname:"/api/chat",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/chat/route.ts",nextConfigOutput:"standalone",userland:b}),{workAsyncStorage:R,workUnitAsyncStorage:x,serverHooks:O}=k;function S(){return(0,s.patchFetch)({workAsyncStorage:R,workUnitAsyncStorage:x})}async function C(e,t,s){k.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let v="/api/chat/route";v=v.replace(/\/index$/,"")||"/";let w=await k.prepare(e,t,{srcPage:v,multiZoneDraftMode:!1});if(!w)return t.statusCode=400,t.end("Bad Request"),null==s.waitUntil||s.waitUntil.call(s,Promise.resolve()),null;let{buildId:A,params:b,nextConfig:R,parsedUrl:x,isDraftMode:O,prerenderManifest:S,routerServerContext:C,isOnDemandRevalidate:E,revalidateOnlyGenerated:P,resolvedPathname:D,clientReferenceManifest:T,serverActionsManifest:L}=w,M=(0,r.normalizeAppPath)(v),_=!!(S.dynamicRoutes[M]||S.routes[D]),F=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,x,!1):t.end("This page could not be found"),null);if(_&&!O){let e=!!S.routes[D],t=S.dynamicRoutes[M];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await F();throw new m.NoFallbackError}}let N=null;!_||k.isDev||O||(N="/index"===(N=D)?"/":N);let j=!0===k.isDev||!_,I=_&&!j;L&&T&&(0,o.setManifestsSingleton)({page:v,clientReferenceManifest:T,serverActionsManifest:L});let H=e.method||"GET",$=(0,i.getTracer)(),q=$.getActiveScopeSpan(),U={params:b,prerenderManifest:S,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:j,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:s.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,s,n)=>k.onRequestError(e,t,s,n,C)},sharedContext:{buildId:A}},G=new d.NodeNextRequest(e),B=new d.NodeNextResponse(t),K=l.NextRequestAdapter.fromNodeNextRequest(G,(0,l.signalFromNodeResponse)(t));try{let o=async e=>k.handle(K,U).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=$.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let s=a.get("next.route");if(s){let t=`${H} ${s}`;e.setAttributes({"next.route":s,"http.route":s,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${v}`)}),r=!!(0,n.getRequestMeta)(e,"minimalMode"),d=async n=>{var i,d;let l=async({previousCacheEntry:a})=>{try{if(!r&&E&&P&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await o(n);e.fetchMetrics=U.renderOpts.fetchMetrics;let d=U.renderOpts.pendingWaitUntil;d&&s.waitUntil&&(s.waitUntil(d),d=void 0);let l=U.renderOpts.collectedTags;if(!_)return await (0,p.sendResponse)(G,B,i,U.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,g.toNodeOutgoingHttpHeaders)(i.headers);l&&(t[f.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==U.renderOpts.collectedRevalidate&&!(U.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&U.renderOpts.collectedRevalidate,s=void 0===U.renderOpts.collectedExpire||U.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:U.renderOpts.collectedExpire;return{value:{kind:y.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:s}}}}catch(t){throw(null==a?void 0:a.isStale)&&await k.onRequestError(e,t,{routerKind:"App Router",routePath:v,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:I,isOnDemandRevalidate:E})},!1,C),t}},c=await k.handleResponse({req:e,nextConfig:R,cacheKey:N,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:S,isRoutePPREnabled:!1,isOnDemandRevalidate:E,revalidateOnlyGenerated:P,responseGenerator:l,waitUntil:s.waitUntil,isMinimalMode:r});if(!_)return null;if((null==c||null==(i=c.value)?void 0:i.kind)!==y.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(d=c.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",E?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),O&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,g.fromNodeOutgoingHttpHeaders)(c.value.headers);return r&&_||m.delete(f.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,h.getCacheControlHeader)(c.cacheControl)),await (0,p.sendResponse)(G,B,new Response(c.value.body,{headers:m,status:c.value.status||200})),null};q?await d(q):await $.withPropagatedContext(e.headers,()=>$.trace(c.BaseServerSpan.handleRequest,{spanName:`${H} ${v}`,kind:i.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},d))}catch(t){if(t instanceof m.NoFallbackError||await k.onRequestError(e,t,{routerKind:"App Router",routePath:M,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:I,isOnDemandRevalidate:E})},!1,C),_)throw t;return await (0,p.sendResponse)(G,B,new Response(null,{status:500})),null}}e.s(["handler",()=>C,"patchFetch",()=>S,"routeModule",()=>k,"serverHooks",()=>O,"workAsyncStorage",()=>R,"workUnitAsyncStorage",()=>x],99280)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__ec5d234f._.js.map